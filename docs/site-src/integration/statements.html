@@includeTop@@
 
    <title>Mulgara &#124; Semantic Store - Statements</title>
    <meta name="keywords" content="Statements, mulgara project, metadata, metastore, metadatabase, datastore, database, scaleable, scalable, transaction, java, open source, rdf, resource description framework" />
	
@@includeMiddle@@		
   
<!-- INNER PAGE NAVIGATION STARTS HERE -->
<div id="navPage">
		<a href="#top">Top</a>	&#124;

		<a href="/integration/statements.html#o2952">Implementing the Interface</a>  
		  
</div>
<!-- INNER PAGE NAVIGATION ENDS HERE -->



<!-- PAGE CONTENT STARTS HERE -->
<div id="content" class="inOut">  
<a name="textonlynav"></a>	  
	





<!--
<p><a href="/integration/parsers.html"><img src="previous.gif" alt="Previous Topic" height="25px" width="23px" vspace="2" hspace="2" align="bottom" border="0" /></a></p>

<p><a href="/integration/compiling.html"><img src="next.gif" alt="Next Topic" height="25px" width="23px" vspace="2" hspace="2" align="bottom" border="0" /></a></p> 


<p class="relatedheading">See Also</p>
<p class="relateditem"><a href="/integration/contenthandlersdev.html">Developing Content Handlers</a></p>
<p class="relateditem"><a href="/integration/contenthandlers.html">Content Handlers</a></p>
<p class="relateditem"><a href="/integration/parsers.html">Parsers</a></p>

 -->




<h4>Statements</h4>

<p>Once the content handler and parser are written, the last step is to create the <code>Statements</code> implementation that navigates the results of the parser's work. <code>Statements</code> objects hold and navigate the triples generated by the parser and are an integral part of any resolver. They are the only component of the content handling side of resolvers that are passed back to the <code>Resolver</code> SPI to have constraints resolved against.</p>

<p>With the <code>Statements</code> implementation you need to decide how it navigates the triples generated by the parsing classes. For the MP3 statements a JRDF <code>Graph</code> is available that has features to allow for the retrieval of an iterator that can be used to navigate the parsed content of the file. The <code>MP3Statements</code> object also handles the parsing of the file content into triples.</p>


<div class="anchor"><a name="o2952">&nbsp;</a></div>
<h5>Implementing the Interface</h5>

<p>After deciding on the best method of navigating the generated statements, it is relatively straightforward to implement the interface. The following code is the MP3 implementation using a JRDF <code>Graph</code> (see <code>MP3Statements.java</code>):</p>

<p class="commandtext">package org.mulgara.content.mp3;<br />
<br />
// Java 2 standard packages<br />
import java.io.*;<br />
import java.net.URI;<br />
import java.net.URISyntaxException;<br />
import java.net.URL;<br />
import java.net.MalformedURLException;<br />
import java.util.*;<br />
import org.xml.sax.*;<br />
<br />
// Third party packages<br />
import org.jrdf.graph.*;<br />
import org.jrdf.graph.mem.*;<br />
import org.apache.log4j.Logger; // Apache Log4J<br />
import org.jrdf.graph.*; // JRDF<br />
import org.jrdf.util.ClosableIterator; // JRDF<br />
import org.jrdf.graph.*; // JRDF<br />
import org.farng.mp3.MP3File;<br />
import org.farng.mp3.TagException;<br />
<br />
// Locally written packages<br />
import org.mulgara.query.Constraint;<br />
import org.mulgara.query.QueryException;<br />
import org.mulgara.query.TuplesException;<br />
import org.mulgara.query.Variable;<br />
import org.mulgara.query.rdf.*;<br />
import org.mulgara.resolver.spi.LocalizeException;<br />
import org.mulgara.resolver.spi.Statements;<br />
import org.mulgara.resolver.spi.ResolverSession;<br />
import org.mulgara.store.StoreException;<br />
import org.mulgara.store.tuples.AbstractTuples;<br />
import org.mulgara.store.tuples.Tuples;<br />
import org.mulgara.content.Content;<br />
import org.mulgara.content.mp3.parser.*;<br />
import org.mulgara.content.mp3.parser.exception.*;<br />
import org.mulgara.content.mp3.parser.api.*;<br />
<br />
public class MP3Statements extends AbstractTuples implements Statements {<br />
<br />
  /** Logger. */<br />
  private static Logger logger =<br />
      Logger.getLogger(MP3Statements.class.getName());<br />
<br />
  /** Column index for subjects */<br />
  public static final int SUBJECT = 0;<br />
<br />
  /** Column index for predicates */<br />
  public static final int PREDICATE = 1;<br />
<br />
  /** Column index for predicates */<br />
  public static final int OBJECT = 2;<br />
<br />
  /** The session used to globalize the RDF nodes from the stream. */<br />
  private ResolverSession resolverSession;<br />
<br />
  /** The queue of triples generated by the ID3 parser. */<br />
  private ArrayList triples;<br />
<br />
  /** The number of statements in the ID3 tag. */<br />
  private long rowCount;<br />
<br />
  /** The current row. If the cursor is not on a row, this will be null */<br />
  private Triple tripleStatement;<br />
<br />
  /** An interator into triples positioned at the next triple. */<br />
  private ClosableIterator nextTriple;<br />
<br />
  /** The content representing the MP3 file */<br />
  private Content content;<br />
<br />
  /** The model which will store the content of parsed mp3 files */<br />
  private Graph model;<br />
<br />
  /**<br />
   * Map ARP anonymous node IDs to {@link BlankNode}s.<br />
   *<br />
   * This is null if no parsing is in progress.<br />
   */<br />
  private Map blankNodeMap = null;<br />
<br />
  //<br />
  // Constructors<br />
  //<br />
<br />
  /**<br />
   * Construct an RDF/XML stream parser.<br />
   *<br />
   * @param content  the content object representing our MP3 file<br />
   * @param resolverSession  session against which to localize RDF nodes<br />
   * @throws IllegalArgumentException if inputStream or<br />
   *   resolverSession are null<br />
   * @throws TuplesException if the inputStream can't be parsed as<br />
   *   RDF/XML<br />
   */<br />
  MP3Statements(Content content, ResolverSession resolverSession) throws<br />
      TuplesException {<br />
<br />
    // Validate &quot;content&quot; parameter<br />
    if (content == null) {<br />
      throw new IllegalArgumentException(&quot;Null \&quot;content\&quot; parameter&quot;);<br />
    }<br />
<br />
    // Validate &quot;resolverSession&quot; parameter<br />
    if (resolverSession == null) {<br />
      throw new IllegalArgumentException(&quot;Null \&quot;resolverSession\&quot; parameter&quot;);<br />
    }<br />
<br />
    // Initialize fields<br />
    this.content = content;<br />
    this.resolverSession = resolverSession;<br />
    this.triples = new ArrayList();<br />
<br />
    // Fix the magical column names for RDF statements<br />
    setVariables(new Variable[] {new Variable(&quot;subject&quot;),<br />
                 new Variable(&quot;predicate&quot;),<br />
                 new Variable(&quot;object&quot;)});<br />
<br />
    try {<br />
<br />
      // Initialise the parser factory<br />
      ParserFactory.getInstance().initialiseFactory();<br />
    } catch (FactoryException factoryException) {<br />
<br />
      throw new TuplesException(&quot;Unable to initialise factory for parsers.&quot;,<br />
                                factoryException);<br />
    }<br />
<br />
    // Load in the RDF conversion of the given mp3 content<br />
    loadURL();<br />
  }<br />
<br />
  /**<br />
   * Load in the RDF conversion from the content object.<br />
   *<br />
   * @throws TuplesException<br />
   */<br />
  private void loadURL() throws TuplesException {<br />
<br />
    // Discard any existing statements<br />
    triples.clear();<br />
<br />
    try {<br />
<br />
      // Initialise the model to be a memory based graph<br />
      model = new GraphImpl();<br />
    } catch (GraphException graphException) {<br />
<br />
      throw new TuplesException(&quot;Unable to create a new graph object.&quot;,<br />
                                graphException);<br />
    }<br />
<br />
    // Create a container for our file<br />
    File contentFile = null;<br />
<br />
    if (!content.getURI().getScheme().equals(&quot;file&quot;)) {<br />
<br />
      // If we are dealing with anything other than a file then use the<br />
      // caching process<br />
<br />
      try {<br />
<br />
        // Convert the URI into a file<br />
        contentFile = getCachedFile(content.newInputStream(), content.getURI());<br />
      } catch (IOException ioException) {<br />
<br />
        throw new TuplesException(<br />
            &quot;Unable to open a stream to the content file [&quot; +<br />
            content.getURI().toString() + &quot;]&quot;, ioException);<br />
      }<br />
    } else {<br />
<br />
      // Files are local and do not need caching<br />
      contentFile = new File(content.getURI());<br />
    }<br />
<br />
    // Parse the content of the file/directory to the model<br />
    parseFile(contentFile);<br />
<br />
    // Parse the stream into RDF statements<br />
    blankNodeMap = new HashMap();<br />
<br />
    try {<br />
<br />
      // Initialize the metadata now that we know the statements<br />
      rowCount = model.getNumberOfTriples();<br />
    } catch (GraphException graphException) {<br />
<br />
      throw new TuplesException(<br />
          &quot;Unable to retrieve number of triples in graph.&quot;,<br />
          graphException);<br />
    }<br />
<br />
    if (logger.isDebugEnabled()) {<br />
<br />
      logger.debug(&quot;Parsed MP3: Found &quot; + rowCount + &quot; triples&quot;);<br />
    }<br />
  }<br />
<br />
  //<br />
  // Methods implementing Statements<br />
  //<br />
<br />
  /**<br />
   * Retrieves the value contained in the subject column for the current triple.<br />
   *<br />
   * @return The subject value for the current triple<br />
   *<br />
   * @throws TuplesException<br />
   */<br />
  public long getSubject() throws TuplesException {<br />
<br />
    return getColumnValue(SUBJECT);<br />
  }<br />
<br />
  /**<br />
   * Retrieves the value contained in the predicate column for the current triple.<br />
   *<br />
   * @return The predicate value for the current triple<br />
   *<br />
   * @throws TuplesException<br />
   */<br />
  public long getPredicate() throws TuplesException {<br />
<br />
    return getColumnValue(PREDICATE);<br />
  }<br />
<br />
  /**<br />
   * Retrieves the value contained in the object column for the current triple.<br />
   *<br />
   * @return The object value for the current triple<br />
   *<br />
   * @throws TuplesException<br />
   */<br />
  public long getObject() throws TuplesException {<br />
<br />
    return getColumnValue(OBJECT);<br />
  }<br />
<br />
  //<br />
  // Methods implementing AbstractTuples<br />
  //<br />
<br />
  /**<br />
   * Resets the counter for triples to be the first.<br />
   *<br />
   * @param prefix The prefix to use<br />
   * @param suffixTruncation The truncation of suffixes to use<br />
   *<br />
   * @throws TuplesException<br />
   */<br />
  public void beforeFirst(long[] prefix, int suffixTruncation) throws<br />
      TuplesException {<br />
<br />
    try {<br />
<br />
      // Get the iterator for statements in the model<br />
      nextTriple = model.find(null, null, null);<br />
    } catch (GraphException graphException) {<br />
<br />
      throw new TuplesException(&quot;Unable to retrieve triple iterator for graph.&quot;,<br />
                                graphException);<br />
    }<br />
<br />
    if (logger.isDebugEnabled()) {<br />
<br />
      try {<br />
<br />
        logger.debug(&quot;-- Getting the before first value from model &quot; + model +<br />
                     &quot; which has statements &quot; + nextTriple.hasNext() + &quot; from &quot; +<br />
                     model.getNumberOfTriples() + &quot; triples&quot;);<br />
      } catch (GraphException graphException) {<br />
<br />
        // Since we are debugging, it is not important if this exception is<br />
        // ignored<br />
      }<br />
    }<br />
  }<br />
<br />
  public Object clone() {<br />
<br />
    MP3Statements cloned = (MP3Statements)super.clone();<br />
<br />
    // Copy immutable fields by reference<br />
    cloned.resolverSession = resolverSession;<br />
    cloned.rowCount = rowCount;<br />
    cloned.tripleStatement = tripleStatement;<br />
    cloned.content = content;<br />
<br />
    // Copy mutable fields by value<br />
    cloned.triples = (ArrayList) triples.clone();<br />
<br />
    return cloned;<br />
  }<br />
<br />
  /**<br />
   * Close the RDF/XML formatted input stream.<br />
   */<br />
  public void close() throws TuplesException {<br />
<br />
    resolverSession = null;<br />
    tripleStatement = null;<br />
    triples = null;<br />
    content = null;<br />
  }<br />
<br />
  /**<br />
   * @param column  0 for the subject, 1 for the predicate, 2 for the object<br />
   */<br />
  public long getColumnValue(int column) throws TuplesException {<br />
<br />
    // Pull the appropriate field from the current triple as a JRDF Node<br />
    Node node = null;<br />
<br />
    switch (column) {<br />
      case SUBJECT:<br />
<br />
        // Try creating the node with a URI reference<br />
        node = tripleStatement.getSubject();<br />
<br />
        break;<br />
      case PREDICATE:<br />
<br />
        // Try to create a URI reference node to represent the predicate<br />
        node = tripleStatement.getPredicate();<br />
<br />
        break;<br />
      case OBJECT:<br />
<br />
        // Create a literal node with the value for objects<br />
        node = tripleStatement.getObject();<br />
<br />
        break;<br />
      default:<br />
<br />
        throw new TuplesException(&quot;No such column &quot; + column);<br />
    }<br />
    assert node != null;<br />
<br />
    // Localize the node<br />
    try {<br />
<br />
      return resolverSession.localize(node);<br />
    } catch (LocalizeException e) {<br />
<br />
      throw new TuplesException(&quot;Couldn't get column &quot; + column + &quot; value&quot;, e);<br />
    }<br />
  }<br />
<br />
  public List getOperands() {<br />
<br />
    return Collections.EMPTY_LIST;<br />
  }<br />
<br />
  public long getRowCount() throws TuplesException {<br />
<br />
    return rowCount;<br />
  }<br />
<br />
  public long getRowUpperBound() throws TuplesException {<br />
<br />
    return getRowCount();<br />
  }<br />
<br />
  public boolean hasNoDuplicates() throws TuplesException {<br />
<br />
    return false;<br />
  }<br />
<br />
  public boolean isColumnEverUnbound(int column) throws TuplesException {<br />
<br />
    switch (column) {<br />
<br />
      case 0:<br />
<br />
      case 1:<br />
<br />
      case 2:<br />
<br />
        return false;<br />
      default:<br />
<br />
        throw new TuplesException(&quot;No such column &quot; + column);<br />
    }<br />
  }<br />
<br />
  public boolean next() throws TuplesException {<br />
<br />
    if (nextTriple.hasNext()) {<br />
<br />
      // Get the next statement in the iterator<br />
      tripleStatement = (Triple) nextTriple.next();<br />
<br />
      if (logger.isDebugEnabled()) {<br />
<br />
        logger.debug(&quot;-- Getting next statement: &quot; + tripleStatement.toString());<br />
      }<br />
<br />
      return true;<br />
    } else {<br />
<br />
      tripleStatement = null;<br />
<br />
      return false;<br />
    }<br />
  }<br />
<br />
  /**<br />
   * Checks whether the given file is a file or directory and then acts<br />
   * accordingly.  It should not be confused with the parseFile method which<br />
   * does the actual conversion from an ID3 tag to RDF.  This method is<br />
   * recursive so subdirectories will be navigated.<br />
   *<br />
   * @param file The file or directory we are checking the content of<br />
   *<br />
   * @throws TuplesException<br />
   */<br />
  private void parseFile(File file) throws TuplesException {<br />
<br />
    if (file.getName().endsWith(&quot;.mp3&quot;)) {<br />
<br />
      // If the file is a valid mp3 file then parse the content into the model<br />
<br />
      // Container for our mp3 file<br />
      MP3File mp3File = null;<br />
<br />
      try {<br />
<br />
        // Create a new MP3 file to represent our content<br />
        mp3File = new MP3File(file);<br />
      } catch (IOException ioException) {<br />
<br />
        throw new TuplesException(&quot;Unable to create mp3 file object for path: &quot; +<br />
                                  file.getAbsolutePath(), ioException);<br />
      } catch (TagException tagException) {<br />
<br />
        throw new TuplesException(&quot;Unable to read ID3 tags for file: &quot; +<br />
                                  file.getAbsolutePath(), tagException);<br />
      }<br />
<br />
      // Create a container for our file id<br />
      String fileId = &quot;&quot;;<br />
<br />
      // Try to use the file uri as the id<br />
      fileId = file.toURI().toString();<br />
<br />
      // Create a new conversion object<br />
      MP3Conversion conversion = new MP3Conversion(mp3File, model, fileId);<br />
<br />
      // Container for our parser object<br />
      ID3Parser parser = null;<br />
<br />
      try {<br />
<br />
        // Get a parser instance<br />
        parser = ParserFactory.getInstance().createID3Parser();<br />
      } catch (FactoryException factoryException) {<br />
<br />
        throw new TuplesException(<br />
            &quot;Unable to create a new ID3Parser due to a factory error.&quot;,<br />
            factoryException);<br />
      }<br />
<br />
      try {<br />
<br />
        // Parse the mp3 into the model<br />
        parser.parseTags(conversion);<br />
      } catch (ParserException parserException) {<br />
<br />
        throw new TuplesException(&quot;Unable to parse tags for file: &quot; +<br />
                                  content.getURI().toString(), parserException);<br />
      }<br />
    } else {<br />
<br />
      throw new TuplesException(&quot;Content object did not contain a valid mime &quot; +<br />
                                &quot;type for parsing.&quot;);<br />
    }<br />
  }<br />
<br />
  /**<br />
   * Creates a locally cached version of a file from an input stream.  If the<br />
   * file already exists then it will not download the file but instead use the<br />
   * cached version.<br />
   *<br />
   * @param inputStream The stream of data we are caching<br />
   * @param uri The uri of the data we are caching<br />
   *<br />
   * @return The file handle to the cached file<br />
   *<br />
   * @throws TuplesException<br />
   */<br />
  private File getCachedFile(InputStream inputStream, URI uri) throws<br />
      TuplesException {<br />
<br />
    // Retrieve the path to the file on the remote host<br />
    String remotePath = uri.getPath();<br />
<br />
    // Retrieve the actual name of the file<br />
    String fileName = remotePath.substring(remotePath.lastIndexOf(&quot;/&quot;) + 1,<br />
                                           remotePath.length());<br />
<br />
    if (logger.isDebugEnabled()) {<br />
<br />
      logger.debug(&quot;Transferring [&quot; + uri + &quot;] to cached file [&quot; + fileName + &quot;]&quot;);<br />
    }<br />
<br />
    // Create a temporary cache directory handle<br />
    File cache = new File(System.getProperty(&quot;java.io.tmpdir&quot;) + File.separator +<br />
                          &quot;resolvercache&quot;);<br />
<br />
    if (!cache.exists()) {<br />
<br />
      // Check that the directory exists and if not then create it<br />
      cache.mkdirs();<br />
    }<br />
<br />
    if (!cache.isDirectory()) {<br />
<br />
      // If we can't use the directory name because a file has it, then just use<br />
      // the temporary directory<br />
      cache = new File(System.getProperty(&quot;java.io.tmpdir&quot;));<br />
    }<br />
<br />
    // Create a new file representing the cached file<br />
    File file = new File(cache, fileName);<br />
<br />
    if (!file.exists()) {<br />
<br />
      // If the file does not exists in the cache already then download the file<br />
<br />
      // Container for our OutputStream to the file<br />
      OutputStream outStream = null;<br />
<br />
      try {<br />
<br />
        // Attempt to create an output stream to the output file<br />
        outStream = new FileOutputStream(file);<br />
      } catch (FileNotFoundException fileNotFoundException) {<br />
<br />
        throw new TuplesException(&quot;Unable to locate output file for caching &quot; +<br />
                                  &quot;of local version of: &quot; + uri.toString(),<br />
                                  fileNotFoundException);<br />
      }<br />
<br />
      // Create an inputStream to read from<br />
      InputStreamReader reader = new InputStreamReader(inputStream);<br />
<br />
      // Container for the bytes in our stream<br />
      int nextByte = 0;<br />
<br />
      try {<br />
<br />
        // Get the first byte of the stream<br />
        nextByte = reader.read();<br />
<br />
        while (nextByte != -1) {<br />
<br />
          // Write out the current byte<br />
          outStream.write(nextByte);<br />
<br />
          // Read the next byte of the file<br />
          nextByte = reader.read();<br />
        }<br />
      } catch (IOException ioException) {<br />
<br />
        throw new TuplesException(&quot;Failed to transfer bytes from source to &quot; +<br />
                                  &quot;cache due to an I/O error.&quot;, ioException);<br />
      } finally {<br />
<br />
        try {<br />
<br />
          // Attempt to shutdown the output stream<br />
          outStream.flush();<br />
          outStream.close();<br />
        } catch (IOException ioException) {<br />
<br />
          throw new TuplesException(&quot;Failed to close output stream to cache&quot;,<br />
                                    ioException);<br />
        }<br />
<br />
        try {<br />
<br />
          // Attempt to close down the input stream reader<br />
          reader.close();<br />
        } catch (IOException ioException) {<br />
<br />
          throw new TuplesException(&quot;Failed to close input stream from &quot; +<br />
                                    uri.toString(), ioException);<br />
        }<br />
      }<br />
    }<br />
<br />
    return file;<br />
  }<br />
}</p>

<p>An analysis of the class is as follows:</p>

<p class="indentcommandtext">package org.mulgara.content.mp3;<br />
<br />
// Java 2 standard packages<br />
import java.io.*;<br />
import java.net.URI;<br />
import java.net.URISyntaxException;<br />
import java.net.URL;<br />
import java.net.MalformedURLException;<br />
import java.util.*;<br />
import org.xml.sax.*;<br />
<br />
// Third party packages<br />
import org.jrdf.graph.*;<br />
import org.jrdf.graph.mem.*;<br />
import org.apache.log4j.Logger; // Apache Log4J<br />
import org.jrdf.graph.*; // JRDF<br />
import org.jrdf.util.ClosableIterator; // JRDF<br />
import org.jrdf.graph.*; // JRDF<br />
import org.farng.mp3.MP3File;<br />
import org.farng.mp3.TagException;<br />
<br />
// Locally written packages<br />
import org.mulgara.query.Constraint;<br />
import org.mulgara.query.QueryException;<br />
import org.mulgara.query.TuplesException;<br />
import org.mulgara.query.Variable;<br />
import org.mulgara.query.rdf.*;<br />
import org.mulgara.resolver.spi.LocalizeException;<br />
import org.mulgara.resolver.spi.Statements;<br />
import org.mulgara.resolver.spi.ResolverSession;<br />
import org.mulgara.store.StoreException;<br />
import org.mulgara.store.tuples.AbstractTuples;<br />
import org.mulgara.store.tuples.Tuples;<br />
import org.mulgara.content.Content;<br />
import org.mulgara.content.mp3.parser.*;<br />
import org.mulgara.content.mp3.parser.exception.*;<br />
import org.mulgara.content.mp3.parser.api.*;</p>

<p class="indent">There are no specific requirements for the packaging of the <code>Statements</code> implementation but it is recommended that you keep it in the same package as your <code>ContentHandler</code> implementation. You must import the following classes:</p>
<ul><li><code>org.mulgara.store.tuples.AbstractTuples</code></li><li><code>org.mulgara.resolver.spi.Statements</code></li><li><code>org.mulgara.query.TuplesException</code></li><li><code>org.mulgara.query.Variable</code></li></ul>
<p class="indent">Any supporting classes can also be imported.</p>

<p class="indentcommandtext">public class MP3Statements extends AbstractTuples implements Statements {</p>

<p class="indent">All statements classes should implement <code>Statements</code> and extend <code>AbstractTuples</code>.</p>

<p class="indentcommandtext">  /**<br />
   * Construct an RDF/XML stream parser.<br />
   *<br />
   * @param content  the content object representing our MP3 file<br />
   * @param resolverSession  session against which to localize RDF nodes<br />
   * @throws IllegalArgumentException if inputStream or<br />
   *   resolverSession are null<br />
   * @throws TuplesException if the inputStream can't be parsed as<br />
   *   RDF/XML<br />
   */<br />
  MP3Statements(Content content, ResolverSession resolverSession) throws<br />
      TuplesException {<br />
<br />
    // Validate &quot;content&quot; parameter<br />
    if (content == null) {<br />
      throw new IllegalArgumentException(&quot;Null \&quot;content\&quot; parameter&quot;);<br />
    }<br />
<br />
    // Validate &quot;resolverSession&quot; parameter<br />
    if (resolverSession == null) {<br />
      throw new IllegalArgumentException(&quot;Null \&quot;resolverSession\&quot; parameter&quot;);<br />
    }<br />
<br />
    // Initialize fields<br />
    this.content = content;<br />
    this.resolverSession = resolverSession;<br />
    this.triples = new ArrayList();<br />
<br />
    // Fix the magical column names for RDF statements<br />
    setVariables(new Variable[] {new Variable(&quot;subject&quot;),<br />
                 new Variable(&quot;predicate&quot;),<br />
                 new Variable(&quot;object&quot;)});<br />
<br />
    try {<br />
<br />
      // Initialise the parser factory<br />
      ParserFactory.getInstance().initialiseFactory();<br />
    } catch (FactoryException factoryException) {<br />
<br />
      throw new TuplesException(&quot;Unable to initialise factory for parsers.&quot;,<br />
                                factoryException);<br />
    }<br />
<br />
    // Load in the RDF conversion of the given mp3 content<br />
    loadURL();<br />
  }</p>

<p class="indent">Since the statements object is closely linked to the content handler, constructors should be given package scope as only the handler uses it. However, if you have packaged your <code>Statements</code> implementation differently to your handler then you need to make it public. Generally the only parameter necessary is the resolver's session. If you are parsing the file as part of the <code>Statements</code> object then it is possible to also require the <code>Content</code> object to allow the parser to find the resource. Any configuration required for the parser should occur here, as well as the conversion of triples to a readable format by the interface.</p>

<p class="indentcommandtext">  /**<br />
   * Load in the RDF conversion from the content object.<br />
   *<br />
   * @throws TuplesException<br />
   */<br />
  private void loadURL() throws TuplesException {<br />
<br />
    // Discard any existing statements<br />
    triples.clear();<br />
<br />
    try {<br />
<br />
      // Initialise the model to be a memory based graph<br />
      model = new GraphImpl();<br />
    } catch (GraphException graphException) {<br />
<br />
      throw new TuplesException(&quot;Unable to create a new graph object.&quot;,<br />
                                graphException);<br />
    }<br />
<br />
    // Create a container for our file<br />
    File contentFile = null;<br />
<br />
    if (!content.getURI().getScheme().equals(&quot;file&quot;)) {<br />
<br />
      // If we are dealing with anything other than a file then use the<br />
      // caching process<br />
<br />
      try {<br />
<br />
        // Convert the URI into a file<br />
        contentFile = getCachedFile(content.newInputStream(), content.getURI());<br />
      } catch (IOException ioException) {<br />
<br />
        throw new TuplesException(<br />
            &quot;Unable to open a stream to the content file [&quot; +<br />
            content.getURI().toString() + &quot;]&quot;, ioException);<br />
      }<br />
    } else {<br />
<br />
      // Files are local and do not need caching<br />
      contentFile = new File(content.getURI());<br />
    }<br />
<br />
    // Parse the content of the file/directory to the model<br />
    parseFile(contentFile);<br />
<br />
    // Parse the stream into RDF statements<br />
    blankNodeMap = new HashMap();<br />
<br />
    try {<br />
<br />
      // Initialize the metadata now that we know the statements<br />
      rowCount = model.getNumberOfTriples();<br />
    } catch (GraphException graphException) {<br />
<br />
      throw new TuplesException(<br />
          &quot;Unable to retrieve number of triples in graph.&quot;,<br />
          graphException);<br />
    }<br />
<br />
    if (logger.isDebugEnabled()) {<br />
<br />
      logger.debug(&quot;Parsed MP3: Found &quot; + rowCount + &quot; triples&quot;);<br />
    }<br />
  }<br />
<br />
  /**<br />
   * Checks whether the given file is a file or directory and then acts<br />
   * accordingly.  It should not be confused with the parseFile method which<br />
   * does the actual conversion from an ID3 tag to RDF.  This method is<br />
   * recursive so subdirectories will be navigated.<br />
   *<br />
   * @param file The file or directory we are checking the content of<br />
   *<br />
   * @throws TuplesException<br />
   */<br />
  private void parseFile(File file) throws TuplesException {<br />
<br />
    if (file.getName().endsWith(&quot;.mp3&quot;)) {<br />
<br />
      // If the file is a valid mp3 file then parse the content into the model<br />
<br />
      // Container for our mp3 file<br />
      MP3File mp3File = null;<br />
<br />
      try {<br />
<br />
        // Create a new MP3 file to represent our content<br />
        mp3File = new MP3File(file);<br />
      } catch (IOException ioException) {<br />
<br />
        throw new TuplesException(&quot;Unable to create mp3 file object for path: &quot; +<br />
                                  file.getAbsolutePath(), ioException);<br />
      } catch (TagException tagException) {<br />
<br />
        throw new TuplesException(&quot;Unable to read ID3 tags for file: &quot; +<br />
                                  file.getAbsolutePath(), tagException);<br />
      }<br />
<br />
      // Create a container for our file id<br />
      String fileId = &quot;&quot;;<br />
<br />
      // Try to use the file uri as the id<br />
      fileId = file.toURI().toString();<br />
<br />
      // Create a new conversion object<br />
      MP3Conversion conversion = new MP3Conversion(mp3File, model, fileId);<br />
<br />
      // Container for our parser object<br />
      ID3Parser parser = null;<br />
<br />
      try {<br />
<br />
        // Get a parser instance<br />
        parser = ParserFactory.getInstance().createID3Parser();<br />
      } catch (FactoryException factoryException) {<br />
<br />
        throw new TuplesException(<br />
            &quot;Unable to create a new ID3Parser due to a factory error.&quot;,<br />
            factoryException);<br />
      }<br />
<br />
      try {<br />
<br />
        // Parse the mp3 into the model<br />
        parser.parseTags(conversion);<br />
      } catch (ParserException parserException) {<br />
<br />
        throw new TuplesException(&quot;Unable to parse tags for file: &quot; +<br />
                                  content.getURI().toString(), parserException);<br />
      }<br />
    } else {<br />
<br />
      throw new TuplesException(&quot;Content object did not contain a valid mime &quot; +<br />
                                &quot;type for parsing.&quot;);<br />
    }<br />
  }<br />
<br />
  /**<br />
   * Creates a locally cached version of a file from an input stream.  If the<br />
   * file already exists then it will not download the file but instead use the<br />
   * cached version.<br />
   *<br />
   * @param inputStream The stream of data we are caching<br />
   * @param uri The uri of the data we are caching<br />
   *<br />
   * @return The file handle to the cached file<br />
   *<br />
   * @throws TuplesException<br />
   */<br />
  private File getCachedFile(InputStream inputStream, URI uri) throws<br />
      TuplesException {<br />
<br />
    // Retrieve the path to the file on the remote host<br />
    String remotePath = uri.getPath();<br />
<br />
    // Retrieve the actual name of the file<br />
    String fileName = remotePath.substring(remotePath.lastIndexOf(&quot;/&quot;) + 1,<br />
                                           remotePath.length());<br />
<br />
    if (logger.isDebugEnabled()) {<br />
<br />
      logger.debug(&quot;Transferring [&quot; + uri + &quot;] to cached file [&quot; + fileName + &quot;]&quot;);<br />
    }<br />
<br />
    // Create a temporary cache directory handle<br />
    File cache = new File(System.getProperty(&quot;java.io.tmpdir&quot;) + File.separator +<br />
                          &quot;resolvercache&quot;);<br />
<br />
    if (!cache.exists()) {<br />
<br />
      // Check that the directory exists and if not then create it<br />
      cache.mkdirs();<br />
    }<br />
<br />
    if (!cache.isDirectory()) {<br />
<br />
      // If we can't use the directory name because a file has it, then just use<br />
      // the temporary directory<br />
      cache = new File(System.getProperty(&quot;java.io.tmpdir&quot;));<br />
    }<br />
<br />
    // Create a new file representing the cached file<br />
    File file = new File(cache, fileName);<br />
<br />
    if (!file.exists()) {<br />
<br />
      // If the file does not exists in the cache already then download the file<br />
<br />
      // Container for our OutputStream to the file<br />
      OutputStream outStream = null;<br />
<br />
      try {<br />
<br />
        // Attempt to create an output stream to the output file<br />
        outStream = new FileOutputStream(file);<br />
      } catch (FileNotFoundException fileNotFoundException) {<br />
<br />
        throw new TuplesException(&quot;Unable to locate output file for caching &quot; +<br />
                                  &quot;of local version of: &quot; + uri.toString(),<br />
                                  fileNotFoundException);<br />
      }<br />
<br />
      // Create an inputStream to read from<br />
      InputStreamReader reader = new InputStreamReader(inputStream);<br />
<br />
      // Container for the bytes in our stream<br />
      int nextByte = 0;<br />
<br />
      try {<br />
<br />
        // Get the first byte of the stream<br />
        nextByte = reader.read();<br />
<br />
        while (nextByte != -1) {<br />
<br />
          // Write out the current byte<br />
          outStream.write(nextByte);<br />
<br />
          // Read the next byte of the file<br />
          nextByte = reader.read();<br />
        }<br />
      } catch (IOException ioException) {<br />
<br />
        throw new TuplesException(&quot;Failed to transfer bytes from source to &quot; +<br />
                                  &quot;cache due to an I/O error.&quot;, ioException);<br />
      } finally {<br />
<br />
        try {<br />
<br />
          // Attempt to shutdown the output stream<br />
          outStream.flush();<br />
          outStream.close();<br />
        } catch (IOException ioException) {<br />
<br />
          throw new TuplesException(&quot;Failed to close output stream to cache&quot;,<br />
                                    ioException);<br />
        }<br />
<br />
        try {<br />
<br />
          // Attempt to close down the input stream reader<br />
          reader.close();<br />
<br />
        } catch (IOException ioException) {<br />
<br />
          throw new TuplesException(&quot;Failed to close input stream from &quot; +<br />
                                    uri.toString(), ioException);<br />
        }<br />
      }<br />
    }<br />
<br />
    return file;<br />
  }</p>

<p class="indent">These three methods are not part of the <code>Statements</code> interface implementation but are responsible for loading in the triples from the input stream represented by the <code>Content</code> object using the parser. The <code>loadURL()</code> method is called from the constructor and sets up the content for parsing, however, the <code>Content</code> interface only allows us access by an input stream so we don't have to worry about protocol. This is a problem for the MP3 parser as it only handles local files. To overcome this, the <code>getCachedFile(InputStream, URI)</code> method exists to allow you to read a remote file into a local cache. Once a local file is created (if the resource wasn't already) you can then call <code>parseFile(File)</code> to generate the JRDF <code>Graph</code> object that you can navigate through to read triples from.</p>

<p class="indentcommandtext">  /**<br />
   * Retrieves the value contained in the subject column for the current triple.<br />
   *<br />
   * @return The subject value for the current triple<br />
   *<br />
   * @throws TuplesException<br />
   */<br />
  public long getSubject() throws TuplesException {<br />
<br />
    return getColumnValue(SUBJECT);<br />
  }<br />
<br />
  /**<br />
   * Retrieves the value contained in the predicate column for the current triple.<br />
   *<br />
   * @return The predicate value for the current triple<br />
   *<br />
   * @throws TuplesException<br />
   */<br />
  public long getPredicate() throws TuplesException {<br />
<br />
    return getColumnValue(PREDICATE);<br />
  }<br />
<br />
  /**<br />
   * Retrieves the value contained in the object column for the current triple.<br />
   *<br />
   * @return The object value for the current triple<br />
   *<br />
   * @throws TuplesException<br />
   */<br />
  public long getObject() throws TuplesException {<br />
<br />
    return getColumnValue(OBJECT);<br />
  }<br />
<br />
  /**<br />
   * @param column  0 for the subject, 1 for the predicate, 2 for the object<br />
   */<br />
  public long getColumnValue(int column) throws TuplesException {<br />
<br />
    // Pull the appropriate field from the current triple as a JRDF Node<br />
    Node node = null;<br />
<br />
    switch (column) {<br />
      case SUBJECT:<br />
<br />
        // Try creating the node with a URI reference<br />
        node = tripleStatement.getSubject();<br />
<br />
        break;<br />
      case PREDICATE:<br />
<br />
        // Try to create a URI reference node to represent the predicate<br />
        node = tripleStatement.getPredicate();<br />
<br />
        break;<br />
      case OBJECT:<br />
<br />
        // Create a literal node with the value for objects<br />
        node = tripleStatement.getObject();<br />
<br />
        break;<br />
      default:<br />
<br />
        throw new TuplesException(&quot;No such column &quot; + column);<br />
    }<br />
    assert node != null;<br />
<br />
    // Localize the node<br />
    try {<br />
<br />
      return resolverSession.localize(node);<br />
    } catch (LocalizeException e) {<br />
<br />
      throw new TuplesException(&quot;Couldn't get column &quot; + column + &quot; value&quot;, e);<br />
    }<br />
  }</p>

<p class="indent">The class maintains a list of the triples represented by the model URL as well as the current triple, which can have the values of each of its columns retrieved using the above methods. Nodes retrieved using these methods must be in their localised form.</p>

<p class="indentcommandtext">  /**<br />
   * Resets the counter for triples to be the first.<br />
   *<br />
   * @param prefix The prefix to use<br />
   * @param suffixTruncation The truncation of suffixes to use<br />
   *<br />
   * @throws TuplesException<br />
   */<br />
  public void beforeFirst (long[] prefix, int suffixTruncation) throws<br />
      TuplesException {<br />
<br />
    try {<br />
<br />
      // Get the iterator for statements in the model<br />
      nextTriple = model.find(null, null, null);<br />
    } catch (GraphException graphException) {<br />
<br />
      throw new TuplesException(&quot;Unable to retrieve triple iterator for graph.&quot;,<br />
                                graphException);<br />
    }<br />
<br />
<br />
    if (logger.isDebugEnabled()) {<br />
<br />
      try {<br />
<br />
        logger.debug(&quot;-- Getting the before first value from model &quot; + model +<br />
                     &quot; which has statements &quot; + nextTriple.hasNext() + &quot; from &quot; +<br />
                     model.getNumberOfTriples() + &quot; triples&quot;);<br />
      } catch (GraphException graphException) {<br />
<br />
        // Since we are debugging, it is not important if this exception is<br />
        // ignored<br />
      }<br />
    }<br />
  }</p>

<p class="indent">Since statements represent a navigable list of tuples they should also have a method for resetting the pointer. This is what the <code>beforeFirst(long[], int)</code> method does. In the case of the MP3 statement set, the iterator is reset to begin interation over the graph's triples.</p>

<p class="indentcommandtext">  /**<br />
   * Close the RDF/XML formatted input stream.<br />
   */<br />
  public void close () throws TuplesException {<br />
<br />
    resolverSession = null;<br />
    tripleStatement = null;<br />
    triples = null;<br />
    url = null;<br />
  }</p>

<p class="indent">After statements are finished with, the <code>close()</code> method is called to free up any resources that are associated with them. Since the MP3 parser takes care of itself, only the objects used by the statement navigation need to be freed up.</p>

<p class="indentcommandtext">  public List getOperands () {<br />
<br />
    return Collections.EMPTY_LIST;<br />
  }<br />
<br />
  public long getRowCount () throws TuplesException {<br />
<br />
    return rowCount;<br />
  }<br />
<br />
  public long getRowUpperBound () throws TuplesException {<br />
<br />
    return getRowCount();<br />
  }<br />
<br />
  public boolean hasNoDuplicates () throws TuplesException {<br />
<br />
    return false;<br />
  }<br />
<br />
  public boolean isColumnEverUnbound (int column) throws TuplesException {<br />
<br />
    switch (column) {<br />
<br />
      case 0:<br />
<br />
      case 1:<br />
<br />
      case 2:<br />
<br />
        return false;<br />
      default:<br />
<br />
        throw new TuplesException(&quot;No such column &quot; + column);<br />
    }<br />
  }</p>

<p class="indent">The above methods find out information about the object, such as the number of rows, whether there are duplicates, if columns are unbound (that is, have no value) or what the operands on the tuples are.</p>

<p class="indentcommandtext">  public boolean next () throws TuplesException {<br />
<br />
    if (nextTriple.hasNext()) {<br />
<br />
      // Get the next statement in the iterator<br />
      tripleStatement = (Triple) nextTriple.next();<br />
<br />
      if (logger.isDebugEnabled()) {<br />
<br />
        logger.debug(&quot;-- Getting next statement: &quot; + tripleStatement.toString());<br />
      }<br />
<br />
      return true;<br />
    } else {<br />
<br />
      tripleStatement = null;<br />
<br />
      return false;<br />
    }<br />
  }</p>

<p class="indent">Statements iterate through the triples of the data store and use the <code>next()</code> method to advance the pointer. The actual triple is stored internally and its values are given out through the <code>getSubject()</code>, <code>getPredicate()</code>, and <code>getObject()</code> methods. If there are no more triples available then the method returns false. In the case of the <code>MP3Statements</code> object, the next value of the iterator is retrieved.</p>

			
    





</div>
<!-- PAGE CONTENT ENDS HERE -->

@@includeBottom@@


